# Lesson: Sieve of Eratosthenes

Source: TrÆ°Æ¡ng PhÆ°á»›c Háº£i


## Prime Number

A positive integer ğ‘ > 1 is called a prime number if and only if ğ‘ has exactly two divisors: 1 and itself. A positive integer greater than 1 that is not prime is called a composite number.

Algorithm to check whether a positive integer ğ‘› is a prime number.

# Algorithm 1: Time complexity ğ‘‚(ğ‘›)
```cpp
  bool IsPrime(int n)
  {
    int cnt = 0;
    for (int i = 1; i <= n; ++i)
      if (n % i == 0) ++cnt;
    return (cnt == 2);
  }
```
# Algorithm 2: Time complexity ğ‘‚(sqrt(n))
  If ğ‘ is a positive divisor of ğ‘› , then there always exists also a positive divisor of ğ‘›, such that a x b = n (b = n / a)
  Suppose: 1 <= a <= b --> a^2 <= a x b <= n --> 1 <= a <= sqrt(n) 
  Since ğ‘› > 1 always has two positive divisors, 1 and itself, we only need to check whether there exists a divisor of ğ‘› from 2 to sqrt(ğ‘›)	â€‹; if such a divisor exists, ğ‘› is not a prime number.
```cpp
  bool IsPrime(int n)
  {
    if (n < 2) return false;
    int m = sqrt(n);
    for (int i = 2; i <= m; ++i)
      if (n % i == 0)
        return false;
    return true;
  }
```
# Algorithm 3: Sieve of Eratosthenes
The sieve of primes was invented by the ancient Greek mathematician Eratosthenes. His sieve algorithm is described as follows:
  Step 1: Write consecutive natural numbers starting from 2.
  Step 2: Take the first number ğ‘¥ in the sequence that has not been crossed out, and remove all of its multiples (except ğ‘¥ itself).
  Step 3: Repeat Step 2 until there are no numbers left in the sequence to remove.
The sieve of primes is applied when it is necessary to check the primality of many integers. Each number in the sieve is assigned one of two states: not crossed out (prime) or crossed out (composite). To create a prime sieve, we construct a one-dimensional array in which the array index corresponds to the value of the integer at that position.
Thus, with a boolean array ğ‘‘ used as the prime sieve, we have d[x] = false if ğ‘¥ is a prime number; otherwise, d[x] = true.

Sieve generation algorithm
```cpp
  bool d[maxN] = {false};
  void Sieve()
  {
    d[0] = d[1] = true;
    m = sqrt(maxN);
    for (x = 2; x <= m; ++x)
      if (d[x] == false)
        for (y = x; y <= maxN/x; ++y)
          d[y*x] = true;
  }
```

